[
  {
    "title": "Generic (Feat. Object, Enum)",
    "url": "/posts/Generic-(Feat.-Object,-Enum)/",
    "categories": "",
    "tags": "generic, Object, Enum",
    "date": "2024-03-25 20:00:00 +0800",
    "content": "Generic이란?  JDK 1.5 부터 지원된 기능으로 클래스나 메서드에서 사용할 내부 데이터 타입을 컴파일 시 미리 지정 할 수 있는 방법이다.  예를 들어 ArrayList&amp;lt;E&amp;gt; 는 ArrayList의 요소 타입을 제네릭으로 처리하기 때문에 요소에 String, Integer 또는 커스텀 객체 등 데이터 타입을 다양하게 담을 수 있다...."
  },
  {
    "title": "스트림(Stream)과 옵셔널(Optional)",
    "url": "/posts/%EC%8A%A4%ED%8A%B8%EB%A6%BC(Stream)%EA%B3%BC-%EC%98%B5%EC%85%94%EB%84%90(Optional)/",
    "categories": "",
    "tags": "java, stream, optional",
    "date": "2024-03-18 20:00:00 +0800",
    "content": "스트림이란?  java8 부터 추가된 기능으로 데이터의 흐름에서 원하는 조건을 거는 filter, 필터링된 값을 담는 map, 최종 결과물 만들기(Collect) 를 수행한다. 이전에도 외부반복자(for, while 등)를 이용하여 위 행위가 가능했으나, 스트림은 내부반복자를 이용하기 때문에 병렬처리가 쉬워지며 코드가 간결해진다.    스트림 단계 스..."
  },
  {
    "title": "람다식(Lamda)",
    "url": "/posts/%EB%9E%8C%EB%8B%A4-(Lamda)/",
    "categories": "",
    "tags": "java, Lamda",
    "date": "2024-03-10 21:00:00 +0800",
    "content": "람다식 사용 방법 전제 조건 단 한개의 추상 메서드만 가지는 인터페이스 필요  interface public interface MaxNumber { 	int getMax(int num1, int num2); }   AS-IS MaxNumber maxNumber = new MaxNumber() { 	@Override 	public int getMax(i..."
  },
  {
    "title": "DB별 varchar(n)의 n 의미",
    "url": "/posts/DB-%EB%B3%84-varchar(n)-%EC%9D%98-n-%EC%9D%98%EB%AF%B8/",
    "categories": "",
    "tags": "DB, oracle, mysql, mariadb",
    "date": "2024-02-20 09:00:00 +0800",
    "content": "Oracle  varchar2(10) 은 10 byte를 의미한다. oracle에서 영어는 1byte, 한글은 2byte 이기 때문에 그동안 막연하게 한글이 들어가는 컬럼은 100자 -&amp;gt; varchar2(200) 으로 생성해왔다.   -- 테스트용 테이블 생성 CREATE TABLE test( 	name varchar2(10) );  -- 한글 ..."
  },
  {
    "title": "Spring Boot3 & Undertow 에서 HTTP Method 제한하기",
    "url": "/posts/Spring-Boot3-&-Undertow-%EC%97%90%EC%84%9C-HTTP-Method-%EC%A0%9C%ED%95%9C%ED%95%98%EA%B8%B0/",
    "categories": "",
    "tags": "SpringBoot, Undertow, 내장WAS",
    "date": "2024-02-08 09:00:00 +0800",
    "content": "모의침투 결과 불필요한 HTTP Method가 허용되어 있어 이에 대한 조치가 필요했다. 보통 WEB이나 WAS 설정파일을 건드려 제한 할 수 있으나, Spring Boot로 내장 WAS 를 사용중이며, Undertow를 사용중에 있어 이 환경의 설정을 처리하고 기록했다.     불필요한 메소드 사용 확인    cmd 창에서 아래 명령어를 통해 허용된..."
  },
  {
    "title": "Edge에서 IE 모드로 진입 후 개발자 도구 열기",
    "url": "/posts/Edge%EC%97%90%EC%84%9C-IE-%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%A7%84%EC%9E%85-%ED%9B%84-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC-%EC%97%B4%EA%B8%B0/",
    "categories": "",
    "tags": "IE, 개발자도구",
    "date": "2024-02-07 10:00:00 +0800",
    "content": "Win+R  단축키를 이용해 실행 창 띄운 후 아래 명령어 실행 %systemroot%\system32\f12\IEChooser.exe    디버그 할 대상 선택하면 제대로 된 개발자 도구가 열린다."
  },
  {
    "title": "자바와 JUnit을 활용한 실용주의 단위 테스트",
    "url": "/posts/%EC%9E%90%EB%B0%94%EC%99%80-JUnit%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8/",
    "categories": "",
    "tags": "JUnit5, Mock, Test",
    "date": "2024-01-29 10:00:00 +0800",
    "content": "JUnit 을 활용하여 단위 테스트를 구축하고, 유지보수 자동 빌드 시 수정된 소스로 인한 기존 서비스에 영향이 없는지를 시스템 화 하고 싶다. 자바와 ‘JUnit을 활용한 실용주의 단위 테스트’ 책과 JUnit 버전 문제로 구글에서 따로 서치한 내용을 함께 서술했다.   JUnit5 설정  build.gradle 에 아래 내용 추가 testImple..."
  },
  {
    "title": "HTTP Method를 활용한 URL 변경",
    "url": "/posts/HTTP-Method%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-URL-%EB%B3%80%EA%B2%BD/",
    "categories": "",
    "tags": "HTTPMethod, RESTful, HTTP",
    "date": "2024-01-29 10:00:00 +0800",
    "content": "기존 URL은 행위가 포함되어 있었다. (Restful URL 규칙 위반) ex) /000ResultList.do , /000ResultDetail.do /000Send.do… URL 길이를 줄이고, HTTP 메서드를 적극 활용하여 URL에서 행위에 대한 내용을 삭제하고자 공부하여 새로 만드는 솔루션에 적용해보았다.   Restful 이란? Rest ..."
  },
  {
    "title": "boot가 아직 준비되지 않았는데 기존 파드가 삭제될때",
    "url": "/posts/boot%EA%B0%80-%EC%95%84%EC%A7%81-%EC%A4%80%EB%B9%84%EB%90%98%EC%A7%80-%EC%95%8A%EC%95%98%EB%8A%94%EB%8D%B0-%EA%B8%B0%EC%A1%B4-%ED%8C%8C%EB%93%9C%EA%B0%80-%EC%82%AD%EC%A0%9C%EB%90%A0%EB%95%8C/",
    "categories": "",
    "tags": "k8s, kubernetes, boot, actuator, startupProbe",
    "date": "2024-01-28 10:00:00 +0800",
    "content": "새로운 버전을 배포할 때,  Deployment는 최신 버전을 먼저 실행하고, 실행이 완료되면 이전 버전의 파드를 삭제한다. 그러나 최신 버전의 파드는 정상적으로 실행됐지만 boot가 아직 준비상태가 아닌데  이전 버전의 파드가 삭제되면 최신 버전의 파드가 준비상태가 될 때 까지 접속 장애가 나타난다. boot가 준비 상태가 되어야만 파드가 실행 완료..."
  },
  {
    "title": "JWT 개발 적용기",
    "url": "/posts/JWT-%EA%B0%9C%EB%B0%9C-%EC%A0%81%EC%9A%A9%EA%B8%B0/",
    "categories": "",
    "tags": "JWT, AccessToken, RefreshToken",
    "date": "2024-01-25 10:00:00 +0800",
    "content": "JWT를 적용하게 된 배경 기존에 개발했던 솔루션은 온프레미스 서버에 구축되는 솔루션이었기에 JWT와 같은 구현이 따로 필요하지 않았다. Spring Security를 이용해 세션으로 사용자 인증을 진행하였으며, 다중화된 서버는 L4장비에서 Hash 방식등을 이용하거나 톰캣 세션 클러스터링을 구현하였기 때문에 문제가 되지 않았다.  그러나 클라우드 서..."
  },
  {
    "title": "JWT 기본",
    "url": "/posts/JWT-%EA%B8%B0%EB%B3%B8/",
    "categories": "",
    "tags": "JWT, Session",
    "date": "2024-01-24 10:00:00 +0800",
    "content": "기존 Session 처리방식  이전에 JWT를 사용하지 않았다면 사용자의 로그인 정보는 Session을 이용하여 처리했을 것이다.  Spring Security를 통해 로그인 된 사용자의 정보를 가져온다던지, session.getAttribute(&quot;로그인한 유저 정보&quot;);  를 가져온다면 session을 이용하는 것이다.  세션을 이용한다면  로그인 ..."
  },
  {
    "title": "Custom Annotaion으로 시스템 접근이력 수집하기",
    "url": "/posts/Custom-Annotation%EC%9C%BC%EB%A1%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A0%91%EA%B7%BC-%EC%9D%B4%EB%A0%A5-%EC%88%98%EC%A7%91%ED%95%98%EA%B8%B0/",
    "categories": "",
    "tags": "customannotaion, AOP",
    "date": "2024-01-24 10:00:00 +0800",
    "content": "사용자가 웹사이트에서 어떤 동작을 요청하였는지 로그를 수집하고 싶었다. AOP 또는 Filter에서 어떤 클래스, 메서드를 실행하였는지 일일이 확인하여 텍스트로 변환 하는 건 너무 번잡해 보여 CustomAnnotation을 이용하기로 했다.     Test Code 작성 우선 간단하게 샘플을 작성하였다. (Controller, Service, Htm..."
  },
  {
    "title": "왜 실행 후 최초 Response는 매우 느릴까",
    "url": "/posts/%EC%99%9C-%EC%8B%A4%ED%96%89-%ED%9B%84-%EC%B5%9C%EC%B4%88-Response%EB%8A%94-%EB%A7%A4%EC%9A%B0-%EB%8A%90%EB%A6%B4%EA%B9%8C/",
    "categories": "",
    "tags": "coldstart, warmup, springboot, jvm",
    "date": "2023-12-18 10:00:00 +0800",
    "content": "💡키워드  • Spring boot Warm up • cold start     현상 Tomcat, Spring Boot 등의 어플리케이션을 실행 후 최초로 REST API 요청 시 Response Time의 딜레이가 많이 긴것을 확인할 수 있다.    이유 JVM 프로세스가 지연로딩 방식을 기반으로 하기 때문에 최초의 한번 요청할때 로드되는 과정 때..."
  }
  
]

